#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# @title    mountssh
# @desc     A portable SSHFS mounting utility script with network checks,
#           timeout auto-unmounting, and remote config editing via terminal.
# @author   Zyren
# @version  1.0
# @license  MIT
# @repo     https://github.com/ZyrenVX/dotfiles
# -----------------------------------------------------------------------------

# Operation flags
ENABLE_DEBUG=0    # Override debug config with --debug flag or manual toggle

readonly PROFILE_DIRECTORY="${HOME}/.custom/$(basename "$0")"

### Default Config Template (Do not touch it) ###
declare -A CONFIG=(
    # Remote SSH username
    [USER]=""
    # Remote host (IP or FQDN (Fully Qualified Domain Name))
    [HOST]=""
    # Remote path to mount
    [REMOTE_MOUNT_POINT]=""
    # Local mount-point
    [LOCAL_MOUNT_POINT]=""
    # SSH Port (Usually 22)
    [PORT]=""
    # Path to SSH private key
    [PRIVATE_KEY]=""
    # Extra SSHFS options
    [SSH_OPTIONS]=""
    # Enable script debugging
    [DEBUG]=0
    # Enable colors
    [COLORS]=1
    # Ping timeout (sec) before mounting
    [PING_TIMEOUT]=3
    # Auto un-mount after N seconds (0 = disable)
    [MOUNT_TIMEOUT]=0
)

### Unified logging logging function
# Supported log types: info | warn | error | debug
function LOG() {
    local type_="$1"
    shift
    local color
    case "$type_" in
        info)  color="${GREEN}" ;;
        warn)  color="${ORANGE}" ;;
        error) color="${RED}" ;;
        debug)
            [[ ${CONFIG[DEBUG]} -eq 1 || $ENABLE_DEBUG -eq 1 ]] || return
            color="${DEBUG_GRAY}"
            ;;
        *) return ;;
    esac
    printf "[%b%b%b]: %b\n" "${color}" "${type_}" "${NC}" "$*"
}

### Show usage
function Usage() {
    local -i colors="$1"
    if [[ $colors -eq 1 ]]; then
        local RED="\033[0;31m" GREEN="\033[0;32m" \
            YELLOW="\033[38;2;212;184;142m" BLUE="\033[38;2;126;117;255m" \
            LIGHT_BLUE="\033[38;2;146;165;200m" BOLD="\033[1m" NC="\033[0m"
    else
        local RED="" GREEN="" YELLOW="" BLUE="" \
            LIGHT_BLUE="" BOLD="" NC=""
    fi

    local scriptName="${YELLOW}$(basename "$0")"

    printf "%b\n" \
        "${BOLD}${LIGHT_BLUE}${scriptName}${NC}${BOLD}${LIGHT_BLUE} - Portable SSHFS mount and SSH utility with network checks and auto unmount${NC}" \
        "" \
        "${BOLD}Usage:${NC}" \
        "  ${scriptName} [options] [profile]${NC}" \
        "" \
        "${BOLD}Filesystem Operations:${NC}"
    printf "    ${GREEN}%-4s ${GREEN}%-32s${NC} %s\n" \
        "-m"   "--mount|mount"        "Mount the SSHFS mount-point" \
        "-u"   "--umount|umount"      "Unmount the SSHFS mount-point" \
        ""     "--ssh|ssh"            "Directly SSH into remote"

    printf "\n${BOLD}Profile Management:${NC}\n"
    printf "    ${GREEN}%-4s ${GREEN}%-32s${NC} %b\n" \
        "-p"   "--profile|profile"                  "Specify the profile name" \
        "-e"   "--edit|edit"                        "Edit the SSHFS configuration file" \
        "-l"   "--list-profiles|list-profiles"      "Show available profiles in ${BLUE}$(EvalVars "${PROFILE_DIRECTORY}")${NC}" \
        ""     "--remove|remove"                    "Remove the profile" \
        ""     "--backup|backup"                    "Backup the original profile with *.bak suffix" \
        ""     "--restore|restore"                  "Restore the backup only if the original profile does not exist" \
        ""     "--cat|cat"                          "Concatenate the config file" \
        ""     "--show-profile|show-profile"        "Display and load a specific profile by name" \
        ""     "--show|show"                        "loaded and show default or specified profile"

    printf "\n${BOLD}Other Options:${NC}\n"
    printf "    ${GREEN}%-4s ${GREEN}%-32s${NC} %s\n" \
        "-c"   "--config|config"            "Specify the full path to config file" \
        "-f"   "--force|force"              "Do not confirm" \
        "-h"   "--help|help"                "Show this help message and exit" \
        "-d"   "--debug|debug"              "Enable debug output" \
        ""     "--no-color"                 "Disable color output" \
        ""     "--version"                  "Show script version"

    printf "\n"
    printf "%b\n" \
        "${BOLD}Description:${NC}" \
        "  This script mounts remote filesystems over SSHFS with automatic network checks," \
        "  optional auto-unmount after a timeout, and supports editing configuration interactively." \
        "  This script also supports direct SSH into remote" \
        "" \
        "${BOLD}Examples:${NC}" \
        "   Mount from profile, remount in subsequent runs" \
        "    $ ${scriptName} <profile>${NC}" \
        "   Opens the profile in your text EDITOR for modification." \
        "    $ ${scriptName} edit <profile>${NC}" \
        "   Mounts the SSHFS filesystem from profile." \
        "    $ ${scriptName} mount <profile>${NC}" \
        "   Unmounts the mounted SSHFS filesystem from profile." \
        "    $ ${scriptName} u(n)mount <profile>${NC}" \
        "   SSH into remote from profile." \
        "    $ ${scriptName} ssh <profile>${NC}" \
        ""
}

### Immediately exit when FATAL is called
function FATAL() {
    local msg="$1"
    local -i exit_code=$2
    [[ $exit_code -gt 0 ]] && {
        printf "\n%s\n%b\n" "$2 errors encountered" "$msg"
        exit "$exit_code"
    }
}

### Installs a package using the system's package manager
# Detects pacman, apt, dnf, or yum
function InstallTool() {
    local -A pkg_map=(
        [fuser]="psmisc"
        [fusermount]="fuse3"
        [sshfs]="sshfs"
        [findmnt]="util-linux"
        [lsof]="lsof"
        [tree]="tree"
    )
    local -a pkgs=()
    for bin in "$@"; do
        local pkg="${pkg_map[$bin]:-$bin}"
        pkgs+=("$pkg")
    done

    if command -v apt &> /dev/null; then
        sudo apt install -y "${pkgs[@]}"
    elif command -v pacman &> /dev/null; then
        sudo pacman --needed -S "${pkgs[@]}"
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y "${pkgs[@]}"
    else
        echo "Unsupported package manager. Please install manually: ${pkgs[*]}"
        return 1
    fi
}

### Check required tools as dependencies
function CheckDependencies() {
    local -a deps=( sshfs ssh fuser tree fusermount findmnt lsof )
    local -a not_found=()
    local yesno=""

    for cmd in "${deps[@]}"; do
        command -v "$cmd" &> /dev/null || not_found+=("$cmd")
    done

    if [[ ${#not_found[@]} -gt 0 ]]; then
        LOG error "${not_found[*]} Not found; Install it first."
        printf "%s: " "Install ${not_found[*]} (y|n)"; read -r yesno
        if [[ $yesno =~ ^(y|Y)$ ]]; then
            InstallTool "${not_found[@]}" || FATAL "Exiting..." 1
        else
            FATAL "Exiting..." 1
        fi
    fi
}

### Auto-detects and sets a TUI text editor (Neovim > Vim > Nano) for config editing
# Falls back to installing vim if none found
function SetTextEditor() {
    local -a Editors=( nvim vim micro nano )
    local found=""
    command -v "${EDITOR}" &> /dev/null && found="${EDITOR}"
    for editor in "${Editors[@]}"; do
        if command -v nvim 1> /dev/null 2>&1; then
            [[ -z ${found} ]] && found="${editor}"
            break
        fi
    done
    if [[ -z $found ]]; then
        LOG warn "NO text editor found on your system"
        LOG info "Installing vim"
        InstallTool "vim"
    fi
    EDITOR=${found:-"vim"}
}

### Set ASCII colors
function SetColors() {
    # ANSI escape sequences for RGB-based color output (eye candy logging in terminal)
    local -i colors="$1"
    if [[ $colors -eq 0 || ${CONFIG[COLORS]} -eq 0 ]]; then
        RED='' GREEN='' BLUE='' DEBUG_GRAY='' LITTLE_BLUE=''
        YELLOW='' SKIN_COL='' GRAY='' ORANGE='' NC=''
        return 0
    fi
    RED='\033[38;2;255;75;75m'
    GREEN='\033[38;2;138;230;81m'
    BLUE='\033[38;2;110;147;235m'
    DEBUG_GRAY='\033[38;2;200;200;200m'
    LITTLE_BLUE='\033[38;2;126;117;255m'
    YELLOW='\033[38;2;226;220;120m'
    SKIN_COL='\033[38;2;170;170;127m'
    GRAY='\033[38;2;125;125;125m'
    ORANGE='\033[38;2;255;170;10m'
    NC='\033[0m'
}

### Special message for termux users
function TermuxUser() {
    ### Helping Messages for Termux user
    LOG info "The termux default user home directory '${LITTLE_BLUE}${1:-""}/data/data/com.termux/files/home${NC}'"
    LOG info "Phone's internal stroage filesystem '${LITTLE_BLUE}${1:-""}/storage/emulated/0/${NC}'"
}

### Change user's exposed paths, username etc with bash-style variables
function EvalVars() {
    local string="$1"
    sed -e "s@${HOME}@\${HOME}@g" \
        -e "s@${USER}@\${USER}@g" <(printf '%s\n' "$1")
}

### Color blue the given path
function ColorPath() {
    echo -e "${LITTLE_BLUE//\\/\\\\}$(EvalVars "$1")${NC//\\/\\\\}"
}

### Displays an ASCII-style script banner
function DrawBanner() {
    printf "%b\n" "${YELLOW}==========================" \
                           "║ SSHFS Mount Utility    ║" \
                           "==========================${NC}"
}

### Nicely formats and prints current loaded config to stdout
# Triggered by --show or DEBUG=1
function ShowLoadedProfile() {
    local profile="$1"
    local -i show_config=$2
    local -a LogVar=("printf" "# ${GRAY}%b${NC}\n# ${ORANGE}%-40b${NC} = %b\n\n")
    local -a PrettyLog=("printf" "%b\n")

    if [[ ${CONFIG[DEBUG]} -eq 1 || $show_config -eq 1 ]]; then
        "${PrettyLog[@]}" \
            "#================#" \
            "# Profile: $(ColorPath "${profile}") #" \
            "#=============#==========================#"
        "${LogVar[@]}" \
            "### SSH Username on the remote device" \
            "USER" "\"${CONFIG[USER]}\"" \
            "### Ip address or FQDN (Fully Qualified Domain Name) of the remote" \
            "HOST" "\"${CONFIG[HOST]}\"" \
            "### SSH Port to use for connection" \
            "PORT" "${BLUE}${CONFIG[PORT]}${NC}" \
            "### Remote path to mount" \
            "REMOTE_MOUNT_POINT" "\"${CONFIG[REMOTE_MOUNT_POINT]}\"" \
            "### Local directory or mount the remote path to" \
            "LOCAL_MOUNT_POINT" "\"${CONFIG[LOCAL_MOUNT_POINT]}\"" \
            "### Private key for SSH authentication" \
            "PRIVATE_KEY" "\"${CONFIG[PRIVATE_KEY]}\"" \
            "### Additional SSH options (e.g., -oreconnect)" \
            "SSH_OPTIONS" "\"${CONFIG[SSH_OPTIONS]}"\" \
            "### Enable bash script debugging (yes or no)" \
            "DEBUG" "${BLUE}${CONFIG[DEBUG]}${NC}" \
            "### Timeout in seconds to wait for the remote host to respond (Network check)" \
            "PING_TIMEOUT" "${BLUE}${CONFIG[PING_TIMEOUT]}${NC}" \
            "### Automatically unmount after this many seconds (0 to disable)" \
            "MOUNT_TIMEOUT" "${BLUE}${CONFIG[MOUNT_TIMEOUT]}${NC}"
    fi
}

### Writes CONFIG associative array values into a temporary bash-style config file
# Used for persistence across script runs
function WriteConfigTemplate() {
    local file_name="$1"
    local -i force=$2
    local profile_path=""
    local -i doesnotExist=0

    if [[ "${file_name}" == "${default_config_profile}" ]]; then
        LOG warn "Temporary config in use."
        profile_path="[warn]: Temporary config in use. For persistence, create a user profile."
    else
        profile_path="Profile: $(EvalVars "${file_name}")"
    fi

    if [[ ! -f "${file_name}" ]]; then
        doesnotExist=1
        if [[ $force -eq 0 ]]; then
            printf "'%b': %s" "$(ColorPath "${file_name}")" "Create new profile (y|n): "
            read -r -n 1 key
            if ! [[ "${key}" =~ ^(y|Y)$ ]]; then
                LOG warn "write operation cacelled for '"$(ColorPath "${file_name}")"'"
                return 1
            fi
        fi
    fi

cat > "${file_name}" << EOF
#!/usr/bin/env bash

#@#==( ${profile_path} )==#@#

### Configuration File for SSHFS Mounting and SSH into remote

### SSH Username on the remote device
USER="${CONFIG[USER]:-"root"}"

### Ip address or FQDN (Fully Qualified Domain Name) of the remote
HOST="${CONFIG[HOST]:-"0.0.0.0"}"

### SSH Port to use for connection
PORT=${CONFIG[PORT]:-22}

### Remote path to mount
REMOTE_MOUNT_POINT="${CONFIG[REMOTE_MOUNT_POINT]:-"/"}"

### Local directory or mount the remote path to
LOCAL_MOUNT_POINT="${CONFIG[LOCAL_MOUNT_POINT]:-"/tmp/mount_$(basename "${file_name}")"}"

### Private key for SSH authentication
PRIVATE_KEY="${CONFIG[PRIVATE_KEY]}"

### Additional SSH options (e.g., -oreconnect)
SSH_OPTIONS="${CONFIG[SSH_OPTIONS]}"

### Enable bash script debugging (yes or no)
DEBUG=${CONFIG[DEBUG]}

### Enable colors
COLORS=1

### Timeout in seconds to wait for the remote host to respond (Network check)
PING_TIMEOUT=${CONFIG[PING_TIMEOUT]}

### Automatically unmount after this many seconds (0 to disable)
MOUNT_TIMEOUT=${CONFIG[MOUNT_TIMEOUT]}

# vim:filetype=bash

EOF
    [[ $doesnotExist -eq 1 ]] && LOG info "New Config file created: $(ColorPath "${file_name}")" || return 0
}

### Compare invalid hosts with given host
function ValidateHost() {
    local -a invalids=("0.0.0.0" "")
    for i in "${invalids[@]}"; do
        if [[ "${CONFIG[HOST]}" == "${i}" ]]; then
            LOG error "Invalid SSH host: '${CONFIG[HOST]}'. Please edit your config."
            FATAL "" 1
        fi
    done
}

### Load config context to current script
function LoadConfigFile() {
    local profile="$1"
    local -i show_config=$2

    if [[ $profile_loaded -eq 1 ]]; then
        ShowLoadedProfile "${profile}" "$show_config"
        return 0
    fi

    [[ -f "${profile}" ]] || FATAL "'${profile}' Not a regular file" 1
    source "${profile}" || FATAL "Counldn't source '$(EvalVars "${profile}")'" 1

    local -a config_vars=(
        USER HOST PORT PRIVATE_KEY
        REMOTE_MOUNT_POINT LOCAL_MOUNT_POINT
        SSH_OPTIONS DEBUG COLORS
        PING_TIMEOUT MOUNT_TIMEOUT
    )
    IFS=$' '
    for key in "${config_vars[@]}"; do
        CONFIG[$key]="${!key}"
        unset "$key"
    done
    [[ -z "${CONFIG[USER]}" ]] && {
        CONFIG[USER]="root"
        LOG error "No SSH username given in the config. Assuming its root now."
    }
    [[ -z "${CONFIG[HOST]}" ]] && {
        LOG error "No SSH hostname given Cannot load the config '$(ColorPath "${profile}")'. Edit the config"
    }
    [[ -z "${CONFIG[REMOTE_MOUNT_POINT]}" ]] && {
        CONFIG[REMOTE_MOUNT_POINT]="/"
        LOG error "No remote mount-point given in the config. Assuming its ${LITTLE_BLUE}/${NC}"
    }
    [[ -z "${CONFIG[LOCAL_MOUNT_POINT]}" ]] && {
        CONFIG[LOCAL_MOUNT_POINT]="/tmp/mount_$(basename "${profile}")"
    }

    SetColors $colors_

    profile_loaded=1

    ShowLoadedProfile "${profile}" "$show_config"
    return 0
}

### Set flags for sshfs command
function SetUpSSH_CMD() {
    local -n array_name_ref=$1
    # Fill array_name_ref array with sshfs flags and parameters
    [[ -n ${CONFIG[PRIVATE_KEY]} ]] && [[ -r "${CONFIG[PRIVATE_KEY]}" ]] && {
        array_name_ref+=("-o" "IdentitiesOnly=yes" "-o" "IdentityFile=${CONFIG[PRIVATE_KEY]}")
    }
    [[ -n "${CONFIG[SSH_OPTIONS]}" ]] && array_name_ref+=("-o" "${CONFIG[SSH_OPTIONS]}")
    [[ -z ${CONFIG[PORT]} && "${CONFIG[USER]}" == u0_a* ]] && CONFIG[PORT]=8022
    [[ -z ${CONFIG[PORT]} ]] && CONFIG[PORT]=22
    [[ -n ${CONFIG[PORT]} ]] && array_name_ref+=("-o" "ssh_command=ssh -p ${CONFIG[PORT]}")
    array_name_ref+=("${CONFIG[USER]:="root"}@${CONFIG[HOST]}:${CONFIG[REMOTE_MOUNT_POINT]:="/"}")
    array_name_ref+=("${CONFIG[LOCAL_MOUNT_POINT]:="/tmp/DEFAULT_MOUNT"}")
}

### Prompts user interactively to fill in CONFIG values
# Uses defaults when input is empty
function GetConfig() {
    # Inner function to prompt user, with default & message
    local -i guess=0

    get_useInput() {
        declare -n ref="$1"       # name reference to the variable to fill
        local prompt="$2"
        local default="$3"
        local default_msg="$4"

        printf "%b%s%b" "${LITTLE_BLUE}" "$prompt" "${NC}"
        [[ -n $default ]] && printf " [%s]" "$default"
        printf ": "

        read -r input

        if [[ -z "$input" && -n "$default" ]]; then
            ref="$default"
            [[ -n "${default_msg}" ]] && echo -e "${default_msg}"
        else
            ref="$input"
        fi
    }

    get_useInput CONFIG[USER] "User" "root" "Assuming you are root."

    get_useInput CONFIG[HOST] "Host (IP or FQDN)" "" ""
    if [[ -z ${CONFIG[HOST]} ]]; then
        echo "Host is required, exiting."
        return 1
    fi

    [[ "${CONFIG[USER]}" == u0_a* ]] && guess=8022 || guess=22
    get_useInput CONFIG[PORT] "Port" "${guess}" "Assuming port ${guess}"
    if [[ -z ${CONFIG[PORT]} ]]; then
        echo "Port is required, exiting."
        return 1
    fi
    get_useInput CONFIG[REMOTE_MOUNT_POINT] "Remote mount-point" "/" "Default ${BLUE}/${NC}"
    get_useInput CONFIG[LOCAL_MOUNT_POINT] "Local mount-point" \
        "/tmp/mount_$(basename "${config_profile}")" "default '${BLUE}/tmp/mount_$(basename "${config_profile}")${NC}'"
    get_useInput CONFIG[MOUNT_TIMEOUT] "Mount timeout (seconds)" "0" "Default 0"
    get_useInput CONFIG[SSH_OPTIONS] "SSH options" "" ""
    get_useInput CONFIG[PRIVATE_KEY] "Private key" "" ""

    # You can optionally unset get_useInput here if you want:
    unset -f get_useInput
}

### Concatenate config using bat and fallback cat command
function Cat_config() {
    local file="$1"
    local should_color="always"
    if command -v bat &> /dev/null; then
        [[ $2 -eq 1 ]] || should_color="never"
        bat --paging=never --color=$should_color --decorations=never --language=bash "${file}"
    else
        cat "${file}"
    fi
}

### Opens config file using $EDITOR
# If config file doesn’t exist or is empty, creates it with defaults
function EditConfig() {
    SetTextEditor # Set the terminal text editor
    local profile="$1"
    local -i force_profile_creation=$2 col=$3
    local diff_output="" should_color="always"
    local yes_no=""

    if [[ ! -s "${profile}" ]]; then
        if ! WriteConfigTemplate "${profile}" "$force_profile_creation"; then
            FATAL "Cannot write '$(ColorPath "${profile}")'. Write aborted" 1
        fi
    fi

    local temp_edit="${profile}.tmp_edit"

    [[ $col -eq 1 ]] || should_color="never"

    if [[ -z "${profile}" ]]; then
        LOG error "No profile was given to edit"
        FATAL "Exiting..." 1
    fi

    LOG info "Edit $(ColorPath "${temp_edit}")"
    cp "${profile}" "${temp_edit}"

    if ${EDITOR:-"vim"} "${temp_edit}"; then
        diff_output=$(diff --color=$should_color "${profile}" "${temp_edit}")
    fi

    if [[ ${#diff_output} -le 0 ]]; then
        LOG info "Edit finished, exiting..."
        return 0
    fi

    LOG info "Your changes"
    printf '%s\n' "${diff_output}"

    printf '%s' "Make changes? (y|n): "; read -r -n 1 yes_no; printf '\n'
    if [[ "${yes_no}" =~ ^(y|Y)$ ]]; then
        cp "${temp_edit}" "${profile}"
    else
        rm -f "${temp_edit}"
        return 0
    fi

    printf '%s' "Show config file? (y|n): " ; read -r -n 1 yes_no; printf '\n'
    if [[ "${yes_no}" =~ ^(y|Y)$ ]]; then
        echo && echo; for i in {1..60}; do printf '%s' "#"; done; printf '\n'
        Cat_config "${temp_edit}" $col
        for i in {1..60}; do printf '%s' "#"; done; printf '\n'
    fi

    LOG info "Edit finished, exiting..."
    rm -f "${temp_edit}" && return 0 || return 1
}

### Checks mount-point, attempt unmount if mount-point exists
function AttemptUnMount() {
    local -r mount="$1"

    if [[ ! -d "${mount}" ]]; then
        LOG warn "'${BLUE}${mount}${NC}' Does not exist"
        return 2
    fi

    removeDir() {
        if rmdir "${mount}" &> /dev/null; then
            LOG info "Cleaned: ${BLUE}${mount}${NC}"
            unset -f removeDir; return 0
        fi
    }

    # If it's not a mount-point, but directory still exist
    if [[ -d "${mount}" ]] && ! mountpoint -q "${mount}"; then
        removeDir
        unset -f removeDir; return 0
    fi

    # Clean lazy unmount
    if timeout 2 fusermount -uz "${mount}" &> /dev/null; then
        LOG info "Successfully lazy unmount via fusermount: ${BLUE}${mount}${NC}"
        removeDir
        unset -f removeDir; return 0
    else
        LOG error "Mount failed"
        umount -l "${mount}" &> /dev/null || {
            LOG warn "Mount still stuck, likely a zombie"
            unset -f removeDir; return 1
        }
        unset -f removeDir; return 0
    fi

    LOG warn "fusermount -uz '${BLUE}${mount}${NC}' failed. Trying fallback methods"

    # Check if anything holding the mount-point
    if command -v "lsof" &> /dev/null; then
        LOG info "files still open:"
        lsof +D "${mount}"
    elif command -v "fuser" &> /dev/null; then
        LOG info "Open files:"
        fuser -vm "${mount}"
    fi

    # SSHFS tied to this mount
    if timeout 2 findmnt -n -T "${mount}" | grep -q "${mount}"; then
        LOG warn "${BLUE}${mount}${NC} is still mounted"
    fi
    # Try lazy unmount again
    if timeout 2 fusermount -uz "${mount}" &> /dev/null; then
        LOG info "Successfully unmount: ${BLUE}${mount}${NC}"
        unset -f removeDir; return 0
    fi
    # Final check in /proc/mounts
    if grep -q "${mount}" /proc/mounts; then
        LOG warn "Mount still listed in /proc/mounts — might be a zombie or stale mount"
        LOG info "Final attempt with lazy unmount"
        if umount -l "${mount}" &>/dev/null; then
        unset -f removeDir; return 0
        else
            unset -f removeDir; return 1
        fi
    fi
}

### Check Reachability of the host using ping command
function HostReachable() {
    local host="$1"
    if ! ping -c 1 -W "${CONFIG[PING_TIMEOUT]}" "${host}" &> /dev/null; then
        LOG error "'${LITTLE_BLUE}${host}${NC}' Not reachable, check the connection."
        return 1
    fi
}

### Check mount directory in /proc/mounts
function CheckMountPoint() {
    local mountPoint="$1"
    if [[ -z "${mountPoint}" ]]; then
        LOG warn "mount-point variable is empty"
        return 1
    fi
    if command -v findmnt &> /dev/null; then
        [[ $(findmnt -n -T "${mountPoint}" -o FSTYPE) == fuse* ]] && return 0 || return 1
    else
        grep -qF "${mountPoint}" /proc/mounts | grep -q fuse && return 0 || return 1
    fi
}

### Create local mount-point (directory)
function CreateLocalMount() {
    local dir="$1"; shift

    mkdir -p "${dir}" &> /dev/null || {
        LOG error "Cannot create '${LITTLE_BLUE}${dir}${NC}'"
        FATAL "Exiting..." 1
    }
}

### Attempt mounts
function AttemptMount() {
    local -a cmd=("$@")
    for i in {1..3}; do
        [[ $i -ge 2 ]] && LOG info "attemting mount $i"
        LOG info "Command: $(${bat} <<< "timeout 4s sshfs ${cmd[*]}")"
        timeout 4s sshfs "${cmd[@]}" && return 0
        sleep $((i*2))
    done
    return 1
}

### Main logic for mounting
function MountSSHFS_() {
    local -a sshfs_cmd=("$@")

    if CheckMountPoint "${CONFIG[LOCAL_MOUNT_POINT]}"; then
        LOG info "${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC} is already mounted"
        return 0
    fi
    # Create local mount-point
    if [[ ! -d "${CONFIG[LOCAL_MOUNT_POINT]}" ]]; then
        CreateLocalMount "${CONFIG[LOCAL_MOUNT_POINT]}"
    fi

    # Mount the remote or local device file system as a fuse.sshfs device using OpenSSH protocol
    if AttemptMount "${sshfs_cmd[@]}"; then
        echo && LOG info "Mounted $(mount | grep --color=always -E "${CONFIG[USER]}|${CONFIG[HOST]}|${CONFIG[LOCAL_MOUNT_POINT]}")"
        [[ ${CONFIG[MOUNT_TIMEOUT]} -gt 0 ]] && {
            (sleep ${CONFIG[MOUNT_TIMEOUT]} && timeout --signal KILL 4 fusermount -u "${CONFIG[LOCAL_MOUNT_POINT]}") &
        }
        [[ "${CONFIG[USER]}" == u0_a* ]] && TermuxUser "${CONFIG[LOCAL_MOUNT_POINT]}"
    else
        LOG error \
            "Failed to mount SSHFS remote:\
     ${SKIN_COL}${CONFIG[USER]}${NC}@${ORANGE}${CONFIG[HOST]}${NC}:${LITTLE_BLUE}${CONFIG[REMOTE_MOUNT_POINT]}${NC}\
     ${LITTLE_BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC} on Port ${CONFIG[PORT]}"

        if AttemptUnMount "${CONFIG[LOCAL_MOUNT_POINT]}"; then
            LOG info "Unmounted: ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
        elif [[ $? -eq 1 ]]; then
            LOG warn "Failed to Unmount ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
            FATAL "Exit reason: Unmount failure" 1
        fi
    fi
}

### If mount directory is mounted, try unmounting
function MountCheck() {
    local -i if_unmount=$1
    local -i if_ssh_only_=$2
    # Handles forced unmounting if its already mounted or --unmount is used
    if  [[ $if_unmount -eq 1 ]] || { [[ $if_ssh_only_ -ne 1 ]] && CheckMountPoint "${CONFIG[LOCAL_MOUNT_POINT]}"; }; then
        AttemptUnMount "${CONFIG[LOCAL_MOUNT_POINT]}";
        if [[ $? -eq 1 ]]; then
            LOG warn "Failed to Unmount ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
            FATAL "Exit reason: Unmount failure" 1
        fi
    fi
}

### Find profile in a known directory
FindProfile() {
    local query="$1"
    local -n ref_var="$2"

    local profile="" base_profile=""
    for profile in "${profile_dir}"/*; do
        base_profile="$(basename "$profile")"
        if [[ "${base_profile}" == "${query}".bak* ]]; then
            ref_var="${base_profile}"
            return 0
        elif [[ "${base_profile}" == "${query}" ]]; then
            ref_var="${base_profile}"
            return 0
        elif [[ "${query}" == "default" ]]; then
            ref_var="default"
            return 0
        fi
    done
    return 1
}

### Parses script arguments like --edit, --show, --unmount, etc.
# Sets flags for conditional execution later
# Main logic of the script
function main() {
    local -a ARGS_ARR=("$@")
    local -a sshfs_cmd=()

    # On-off Flags
    local -i mount=0 unmount=0 ssh_only_=0
    local -i ls_config_dir=0 edit_profile=0 show_config=0 cat_config=0
    local -i force=0
    local -i show_usage=0
    local -i remove_profile=0 backup_profile=0 restore_profile_from_bak=0

    # global vars
    local -g profile_loaded=0 colors_=1
    local -g default_config_profile="${PROFILE_DIRECTORY}/default"
    local -g profile_dir="${PROFILE_DIRECTORY}"
    local -g bat=""

    # String variables for profile
    local config_profile="${default_config_profile}" backup_config_profile=""
    local requested_profile_base="" show_requested_profile=""

    command -v bat &> /dev/null && bat="bat --color=always --paging=never --decorations=never --language=asm"

    for (( i = 0; i < ${#ARGS_ARR[@]}; i++ )); do
        arg="${ARGS_ARR[$i]}"
        next_arg="${ARGS_ARR[$((i+1))]}"

        case "${arg}" in
            -e|--e*|e*)
                edit_profile=1
                ;;
            -d|--deb*|deb*)
                CONFIG[DEBUG]=1
                ENABLE_DEBUG=1
                ;;
            -p=*|--pro*=*|pro*=*)
                requested_profile_base="${arg#*=}"
                ;;
            -p*|--pro*|pro*)
                requested_profile_base="${next_arg}"
                ((i++))
                ;;
            --sh*pr*=*|sh*pr*=*)
                show_requested_profile="${arg#*=}"
                ;;
            --sh*pr*|sho*pro*)
                show_requested_profile="${next_arg}"
                ((i++))
                ;;
            -c=*|--con=*|con=*)
                config_profile="${arg#*=}"
                ;;
            -c|--con*|con*)
                config_profile="$next_arg"
                ((i++))
                ;;
            --show|show)
                show_config=1
                ;;
            --cat|cat)
                cat_config=1
                ;;
            --rm|--rem*|rm|rem*)
                remove_profile=1
                ;;
            --ba*|ba*)
                backup_profile=1
                ;;
            --res*|res*)
                restore_profile_from_bak=1
                ;;
            --ss*|ss*)
                ssh_only_=1
                ;;
            -l|-ls*|--tr*|--li*|--ls*|li*|ls*|tr*)
                ls_config_dir=1
                ;;
            -f|-force|force)
                force=1
                ;;
            --no-color|--nocolor)
                CONFIG[COLORS]=0
                colors_=0
                ;;
            -m|--mount|mount)
                mount=1
                ;;
            -u|--u*mount|u*mount)
                unmount=1
                ;;
            -h|--help|help)
                show_usage=1
                ;;
            *)
                FindProfile "${arg}" "requested_profile_base"
                if [[ "${requested_profile_base}" != "${arg}" ]]; then
                    LOG error "Invalid argument: $arg"
                    FATAL "Exit reason: Invalid argument passed" 1
                fi
                ;;
        esac
    done

    SetColors $colors_

    if [[ $show_usage -eq 1 ]]; then
        Usage $colors_ && exit 0
    fi

    CheckDependencies

    mkdir -p "${profile_dir}"

    if [[ $ls_config_dir -eq 1 ]]; then
        echo && LOG info "Available Profiles:\n"
        local -a temp_tree_data=("")
        local tree=(tree -C -Fp --si -u)
        [[ $colors_ -eq 0  ]] && tree=(tree -n -Fp --si -u)
        mapfile -t temp_tree_data < <(${tree[@]} "${profile_dir}")
        printf '%s\n' "${temp_tree_data[@]}" | sed -e "s@${HOME}@\${HOME}@g" -e "s@${USER}@\${USER}@g"
        unset temp_tree_data tree
        return 0
    fi

    # Process the requested profile
    if [[ -n "${requested_profile_base}" || -n "${show_requested_profile}" ]]; then
        local requested="" base="" should_show_config=0 config_exists=0
        if [[ -n "${show_requested_profile}" ]]; then
            requested="${show_requested_profile}"
            should_show_config=1
        elif [[ -n "${requested_profile_base}" ]]; then
            requested="${requested_profile_base}"
        fi

        FindProfile "${requested}" "base"
        if [[ -s "${profile_dir}/${base}" && -f "${profile_dir}/${base}" ]]; then
            config_profile="${profile_dir}/${base}"

            if [[ "${base}" == *.bak* ]]; then
                config_profile="${profile_dir}/${base%.bak*}"
                backup_config_profile="${profile_dir}/${base}"
                config_exists=1
            fi

            config_exists=1
        else
            if [[ "${base}" != "default" ]]; then
                if ! WriteConfigTemplate "${profile_dir}/${requested}" "$force"; then
                    LOG warn "requested profile '$(ColorPath "${profile_dir}/${requested}")' write abort" 1
                    config_exists=0
                fi
                config_profile="${profile_dir}/${requested}"
            fi

        fi

        if [[ "$(basename ${config_profile})" == "default" ]]; then
            config_profile="${default_config_profile}"
            config_exists=1
        fi

        if [[ $config_exists -eq 1 && $profile_loaded -eq 0 ]] && [[ -z $backup_config_profile ]]; then
            LoadConfigFile "${config_profile}" "$should_show_config"
        fi
        unset requested base should_show_config config_exists
    fi

    # Restore from backup file
    if [[ $restore_profile_from_bak -eq 1 && -n "${backup_config_profile}" ]]; then
        if [[ -f "${backup_config_profile}" ]]; then
            cp "${backup_config_profile}" "${backup_config_profile%.bak*}" && \
                LOG info "Restored '$(ColorPath "${backup_config_profile}")' ==> $(ColorPath "${backup_config_profile%.bak*}")"
        else
            LOG warn "No such '$(ColorPath "${backup_config_profile}")' backup exists"
        fi
    fi

    # Prompt user to provide config interactively and save the config
    if [[ ! -s "${config_profile}" ]]; then
        [[ -f "${config_profile}" ]] || \
            LOG warn "New Config '$(EvalVars "${config_profile}")'. Edit or Fill the values interactively"
        local userInput
        while true; do
            printf '%s: ' "Edit using EDITOR or Interactive filling? (e|i)"; read -r -n 1 userInput; printf '\n'
            if [[ "${userInput}" =~ ^(e|E)$ ]]; then
                # Get config using text $EDITOR
                EditConfig "${config_profile}" "$force" "$colors_"
                edit_profile=0 # prevent next edit trigger
                break
            elif [[ "${userInput}" =~ ^(i|I)$ ]]; then
                # Get config values interactively
                GetConfig || FATAL "Exit reason: User interuppted the process" 1
                break
            elif [[ "${userInput}" =~ ^(q|Q)$ ]]; then
                # Just exit the script on Q
                return 1
            else
                LOG error "Only press (\`e\`|\`i\`) or \`q\` to exit"
            fi
        done
        # After getting values, write to config
        WriteConfigTemplate "${config_profile}" "$force" || FATAL "Exit reason: User aborted profile write" 1
        unset userInput
    fi

    # Load profile and show it
    if [[ $show_config -eq 1 ]]; then
        LoadConfigFile "${config_profile}" "$show_config"
    fi

    # Concatenate profile
    if [[ $cat_config -eq 1 ]]; then
        LOG info "Profile: $(ColorPath "${config_profile}")" && echo
        Cat_config "${config_profile}" $colors_
    fi

    # Backup profile
    if [[ $backup_profile -eq 1 ]]; then
        if [[ -f "${config_profile}" ]]; then
            cp "${config_profile}" "${config_profile}.bak" && \
                LOG info "Backup '$(ColorPath "${config_profile}")' ==> $(ColorPath "${config_profile}").bak"
        fi
    fi

    # Remove profile
    if [[ $remove_profile -eq 1 ]]; then
        [[ -f "${config_profile}" ]] && rm "${config_profile}" && LOG info "[!] Removed '$(ColorPath "${config_profile}")'"
    fi

    # Edit profile
    if [[ $edit_profile -eq 1 ]]; then
        EditConfig "${config_profile}" "$force" "$colors_"
        return 0
    fi

    # Unmount local mount-point
    if [[ $unmount -eq 1 ]]; then
        AttemptUnMount "${CONFIG[LOCAL_MOUNT_POINT]}";
        if [[ $? -eq 1 ]]; then
            LOG warn "Failed to Unmount ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
            FATAL "Exit reason: Unmount failure" 1
        fi
    fi

    if [[ $ssh_only_ -eq 0 && $mount -eq 0 ]]; then
        return 0
    fi

    # Load the config file into current scope of the script
    LoadConfigFile "${config_profile}" $show_config

    # Before mounting, check if remote is alive and listening
    ValidateHost "${CONFIG[HOST]}"
    HostReachable "${CONFIG[HOST]}" || FATAL "Exit reason: Host unreachable" 1

    # ASCII Banner
    DrawBanner

    # SSH and mount
    if [[ $ssh_only_ -eq 1 && $mount -eq 1 ]]; then
        MountCheck $unmount $ssh_only_

        echo && LOG info "=====> Mount and SSH into remote <=====" && echo
        LOG info "Mounting remote: '${CONFIG[HOST]}' from profile $(ColorPath "${config_profile}")" && echo

        SetUpSSH_CMD "sshfs_cmd"
        MountSSHFS_ "${sshfs_cmd[@]}"

        LOG info "SSH into '${CONFIG[HOST]}' from profile $(ColorPath "${config_profile}")" && echo
        LOG info "Command: $(${bat} "ssh -p ${CONFIG[PORT]} ${CONFIG[USER]-root}@${CONFIG[HOST]}")" && echo
        ssh -p "${CONFIG[PORT]}" "${CONFIG[USER]-"root"}@${CONFIG[HOST]}"
        return 0
    fi

    # No mount, SSH only
    if [[ $ssh_only_ -eq 1 ]]; then

        echo && LOG info "=====> SSH only <=====" && echo
        LOG info "SSH into '${CONFIG[HOST]}' from profile $(ColorPath "${config_profile}")" && echo

        [[ "${CONFIG[USER]}" == u0_a* ]] && TermuxUser && echo
        LOG info "Command: $(${bat} <<< "ssh -p ${CONFIG[PORT]} ${CONFIG[USER]-root}@${CONFIG[HOST]}")" && echo
        ssh -p "${CONFIG[PORT]}" "${CONFIG[USER]-"root"}@${CONFIG[HOST]}"
        return 0
    fi

    ## No SSH, Mount only
    if [[ $mount -eq 1 ]] || [[ $# -eq 1 && -n $requested_profile_base ]]; then
        [[ $# -eq 1 ]] && LOG info "No action specified defaulting to mount"
        MountCheck $unmount $ssh_only_

        echo && LOG info "=====> Mount only <=====" && echo
        LOG info "Mounting remote: '${CONFIG[HOST]}' from profile $(ColorPath "${config_profile}")" && echo

        SetUpSSH_CMD "sshfs_cmd"
        MountSSHFS_ "${sshfs_cmd[@]}"

        return 0
    fi
}

main "$@"

